//
// Created by wizard on 7/12/25.
//

#define INTERNAL_CPP
#include "../internal/cbrtf.h"
#include "../../attribute/attribute.h"
#include "../../round_mode.h"
#include "../internal/f32.h"
#include "../internal/fmaf.h"
#include "../internal/numbers.h"
#undef INTERNAL_CPP

/* CORRECTLY ROUNDED CUBIC ROOT EVALUATION IN DOUBLE
 *                   PRECISION
 *      ALEXEI SIBIDANOV AND PAUL ZIMMERMANN
 *
 * https://core-math.gitlabpages.inria.fr/cbrt64.pdf
 *
 * This implementation is based off of the fantastic paper above, as well as the CORE-MATH source code:
 *    https://gitlab.inria.fr/core-math/core-math
 * by the same authors.
 */

/*
 * You can use the decimal values for the following constants provided the
 * compiler will convert them correctly.
 *
 * I ported it to float myself, so that attribution goes to me :)
 */

static const float cscale[3] = {
   1.0f,
   0x1.428a3p+0f,    // static_cast<float>(2^(1/3)) ~ 1.25992107391357421875
   0x1.965feap+0f    // static_cast<float>(2^(2/3)) ~ 1.58740103244781494141
};
/*
 * Cubic minimax approximation of x^(1/3) on range [1, 2]
 * Generated by Sollya with the following command:
 *    > fpminimax(x^(1/3), 3, [|24...|], [1,2]);
 *   Warning in fpminimax: the list of formats is a numerical end-elliptic list.
 *   This is deprecated and will be forbidden in future releases.
 *   0.5528233051300048828125 + x * (0.587114512920379638671875 + x *
 *   (-0.16296981275081634521484375 + x * 2.310499362647533416748046875e-2))
 *
 *   Maximum error is at x = 2.0, with an error of ~9.197e-05.
 *   (Tested in Desmos graphing calculator)
 */
static const float c[4] = {
   0x1.1b0ba8p-1f,
   0x1.2c9a46p-1f,
   -0x1.4dc31ep-3f,
   0x1.7a8d5ep-6f
};

//These numbers correspond to the cubic variant of Newton's method.
static const float t = 0x1.555556p-2f,   // (1/3)
                   t1 = 0x1.c71c72p-3f;  // (2/9)

static constexpr float rscale[3] = { //This way, we can compute 1/_zz just by multiplying, not dividing
   1.0f, 0.5f, 0.25f
};

extern "C"
   _internal
   float _ieee754_cbrtf(const float _f) {
   _ieee754_f32 _fx(_f),
                _i(1.0f); //Basically our temporary union where we do all the work.
   int _e = _fx._f_core._exp;
   int _sgn = _fx._f_core._sgn;
   _fx._i &= flt_abs_mask; //cbrt(-x) = -cbrt(x)
   if (_e == 255)
      return _f + _f; // inf or NaN
   if (_fx._i << 1 == 0)
      return _f; // +-0
   if (!_e) { //Subnormal
      _fx._f *= 0x1p23f; //Normalize mantissa
      _e = (_fx._f_core._exp - 23); //Recalculate exponent
   }
   _e += 257;
   /*
    * Where does 257 come from?
    * Well, we want the unbiased exp, and then, since some _e would be negative,
    * we add 384 which is a safe multiple of 3. Then, _unbiased_cbrt_exp = _e/3 - 128
    * (which is 384 / 3). So, 257 is just 384 - 127. We subtract to get rid of the bias.
    * 384 is completely heuristic! There is no deep mathematical reason for this number. It
    * just ensures the exponent is positive, while being a nice multiple of 3 that is above 127.
    */
   _i._f_core._mantissa = _fx._f_core._mantissa;
   //Now _i._f e [1, 2), so we can use our approximation later
   unsigned int _er = (_e / 3)/*384 / 3*/, _es = _e % 3; //Exponent of result, and exponent of scaling (For cscale[_es])
   /*
    * Now we can move on, because we know that cbrt(x) = cbrt(_i._f) * 2^(_er) * _cscale[_es]
    * cbrt(_i._f) * _cscale[_es] condenses to cbrt(_zz), where _zz e [1, 8). Then we refine
    * on that.
    */
   float _z = _i._f, _z2 = _z * _z;
   _i._f_core._exp += _es; //From 0 to 2
   float _zz = _i._f; //Now _zz e [1, 8)
   _i._f = cscale[_es];
   float _c0 = c[0] + _z * c[1];
   float _c2 = c[2] + _z * c[3];
   float _y = _c0 + _z2 * _c2,
         _y2 = _y * _y;
   //_y approximates _z ^ (1/3) currently with an absolute max error of ~9.197e-05
   float _r = 1.0f / _z, _rr = _r * rscale[_es]; //Clever trick to always get the right _rscale value
   float _h = _y2 * (_y * _r) - 1;
   //_h is the error of the approximation
   _y -= (_h * _y) * (t - t1 * _h);
   //Now we scale by our cscale value to get an approximation of cbrt(x) e [1, 8).
   _y *= _i._f;
   //Now _y approximates _zz ^ (1/3)
   //We then perform some precise Newton's method.
   _y2 = _y * _y; //Rough estimate for _y2
   /*
    * Side note: You could replace the c_fmaf calls with Dekker arithmetic
    * or some other precision hack, but it will probably break in non-nearest
    * rounding modes, so this is the safe option that prioritizes acuracy
    * over speed.
    */
   float _y2l = c_fmaf(_y, _y, -_y2);
   float _y3 = _y2 * _y, //Rough estimate for _y3
         _y3l = c_fmaf(_y, _y2, -_y3) + _y * _y2l;
   //_y3 + _y3l now represents _y^3 with a huge amount of accuracy
   _h = ((_y3 - _zz) + _y3l) * _rr; //Simple Newton iteration
   //(_y3 - _zz) + _y3l ensures that we prevent rounding that would happen if we did _y3 + _y3l - _zz.
   float _dy = _h * (_y * t); //Then, the new approximation is _y - _dy
   float _y1 = _y - _dy;
   _dy = (_y - _y1) - _dy;
   /*
    * Now, _y1 + _dy should be a good approximation for _zz^(1/3)
    * More specifically, |_dy| should be less than 1/2ulp(_y)
    */
   int _rnd = c_get_f_round();
   if (_rnd != _round_nearest) {
      //In rounding to nearest, our value of _y1 is already correctly-rounded.

      _i._f = _y1; //For incrementing if not in _round_nearest
      /*
       * In directed rounding modes, sometimes cube roots that should be
       * exact are misplaced by -1ulp. To fix this, we check _dx, and if
       * it is over/under a certain treshold obtained via testing, we can
       * safely increment _y1, and we get the correct value. We check if
       * there is a possibility of this by seeing if the first 16 trailing
       * zeros are one. (Because an exact cube root will have 8 significant
       * bits only by necessity, since you multiply 3 times which would fill
       * the 24-bit mantissa).
       *
       * Admittedly, this is a somewhat different way to correct these errors
       * than what the paper does, but it still empirically gives correct
       * results.
       */
      /*
       * Sadly, this is not the end of our problems. There are still a select
       * few worst cases that are always off by an ulp. Fortunately, we are always
       * one ulp too low, so we can store the values in an array _wlist[], and if
       * our value matches a value in that array, we increment our float. This is
       * covered after the possibly misplaced exact cube root.
       */
      if ((_i._i & 0xffff) == 0xffff) {
         //Potential exact root candidate - lower 16 bits are all-zero / all-one
         switch (_rnd) {
            case _round_zero:
               if (_dy >= 0x1.ffffdcp-24f) // ~ 1.19209161653088813182e-7f | 2^-23 = 1.1920928955078125e-7f
                  /*
                   * Sometimes _dy is close to 1ulp but not quite for some reason, so we manually
                   * round up to get to the exact float. This specific value was the largest that
                   * would correct all incorrect cases of this type, leaving only 3 that must be
                   * hardcoded in _wlist[].
                   */
                     _i._i ++;
               break;
            case _round_down:
               if (_dy >= 0x1.fffffp-24f) // ~ 1.1920923270736238919198513031005859375e-07f
                  /*
                   * This the value of _dy for all but one of the _wlist[] listings for _round_down.
                   * Tests show that this condition does not let in unintended values, so now we
                   * only have 1 case to check, which we will just inline in the later switch...
                   */
                     _i._i ++;
            default: //_round_up
               break; /*
                       * _round_up doesn't have these misleading cases, just 7
                       * miscellaneous cases which we can easily put in _wlist[].
                       */
         }
      }
      static constexpr float _wlist[] = {
         //_round_up worst cases - 7 entries:
         0x1.0fd6b8p+1f, //2.1237401962280273437500f
         0x1.92916ap+1f, //3.1450626850128173828125f
         0x1.b42b70p+1f, //3.4075756072998046875000f
         0x1.d9a392p+1f, //3.7003042697906494140625f
         0x1.f867a4p+1f, //3.9406628608703613281250f
         0x1.33d31ap+2f, //4.8097596168518066406250f
         0x1.a0904cp+2f, //6.5088071823120117187500f
         //_round_zero worst cases - 3 entries:
         0x1.0fd6b8p+1f, //2.1237401962280273437500f
         0x1.d24766p+2f, //7.2856078147888183593750f
         0x1.e06e6cp+2f  //7.5067396163940429687500f
      };
      if (_rnd == _round_down)
         _i._i += (_zz == 0x1.26e8dap+2); // 4.607962131500244140625f
      else { //_round_up and _round_zero - (The two rounding modes that use _wlist[]):
         //Silly little trick I cooked up...
         int _a = 0, _b = 7;
         if (_rnd == _round_zero) { //To get to the right indices in _wlist[]
            _a = 7;
            _b = 10;
         }
         for (int _j = _a; _j < _b; _j ++) {
            _i._i += (_zz == _wlist[_j]);
         }
      }
      _y1 = _i._f;
   }
   //Assemble final float
   _fx._f = _y1;
   _fx._f_core._exp += _er - 128;
   //_fx._f_core._exp += 127;
   _fx._f_core._sgn = _sgn;
   return _fx._f;
}

extern "C"
   _strong_alias(c_cbrtf, _ieee754_cbrtf);